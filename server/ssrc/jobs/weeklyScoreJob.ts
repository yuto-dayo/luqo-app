import { dbClient, getEventsByUserPeriod, getFixedScore, getBanditState, saveBanditState, appendEvent } from "../lib/dbClient";
import { generateLuqoScore } from "../lib/openaiClient";
import { LuqoBanditBrain } from "../lib/banditBrain";
import { supabaseAdmin } from "../services/supabaseClient"; // バッチは常にAdmin権限
import type { EventRow } from "../models/events";
import type { BanditArmId } from "../types/banditState";
import { logger } from "../lib/logger";

const brain = new LuqoBanditBrain();

/**
 * 週次スコア確定バッチ
 * 毎週月曜早朝に実行され、前週（月曜〜日曜）のスコアを確定・学習する
 */
export async function runWeeklyScoreBatch() {
    logger.info("[WeeklyBatch] Starting weekly score batch...");

    try {
        // 1. 対象期間の計算（前週の月曜 00:00 〜 今週の月曜 00:00）
        // 実行日が「月曜」であることを前提とする
        const now = new Date();
        // UTCでの計算を推奨するが、要件に合わせてJST/UTCを調整
        // ここではシンプルに「実行時の7日前〜現在」とする
        const endDate = now.toISOString(); // 今（月曜早朝）
        const startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString(); // 7日前

        logger.info(`[WeeklyBatch] Target period: ${startDate} ~ ${endDate}`);

        // 2. 全アクティブユーザー取得
        const userIds = await dbClient.getAllActiveUserIds(supabaseAdmin);
        logger.info(`[WeeklyBatch] Found ${userIds.length} active users.`);

        // 3. ユーザーごとに処理
        for (const userId of userIds) {
            await processUserWeeklyScore(userId, startDate, endDate);
        }

        logger.info("[WeeklyBatch] Batch completed successfully.");
    } catch (err) {
        logger.error("[WeeklyBatch] Critical error in batch execution:", err);
    }
}

async function processUserWeeklyScore(userId: string, startDate: string, endDate: string) {
    try {
        // A. 既に確定済みか確認（期間を指定して検索が必要だが、簡易的に「今月」または「期間重複」チェック）
        // getFixedScoreは現在month検索のみだが、重複実行しても冪等性があれば問題ない
        // ここでは念のため、同じstartDateの確定ログがあるかチェックするロジックを入れるのが安全
        const { data: existing } = await supabaseAdmin
            .from("events")
            .select("id")
            .eq("user_id", userId)
            .eq("kind", "luqo_score_fixed")
            .contains("payload", { startDate }) // startDateが一致するものを探す
            .limit(1);

        if (existing && existing.length > 0) {
            logger.info(`[WeeklyBatch] Skipping ${userId}: Already finalized for ${startDate}`);
            return;
        }

        logger.info(`[WeeklyBatch] Processing ${userId}...`);

        // B. イベント取得
        const events = await getEventsByUserPeriod(userId, startDate, endDate, supabaseAdmin);

        // ログが少なすぎる場合はスキップするか検討（ここでは0件でも実行する仕様とする）
        const logs = events.map((e: EventRow) => ({ text: e.text ?? "" }));

        // C. スコア計算 (AI)
        // ★ Context Injection (Batch)
        const { getUserContext } = await import("../services/contextService");
        const userContext = await getUserContext(userId, startDate, endDate);

        const baseScore = await generateLuqoScore(logs, undefined, userContext);

        // D. 調整 (Just Culture)
        const { data: adjustments } = await supabaseAdmin
            .from("events")
            .select("*")
            .eq("user_id", userId)
            .eq("kind", "q_score_adjustment")
            .gte("created_at", startDate)
            .lt("created_at", endDate);

        let totalDelta = 0;
        const badges: string[] = [];
        const hiddenReasons: string[] = [];

        if (adjustments) {
            for (const adj of adjustments) {
                const p = adj.payload as any;
                totalDelta += (p.delta || 0);
                if (p.badge) badges.push(p.badge);
                if (p.reason) hiddenReasons.push(p.reason);
            }
        }

        const finalQ = Math.max(0, Math.min(100, baseScore.Q + totalDelta));

        const finalScore = {
            ...baseScore,
            Q: finalQ,
            total: Math.round(baseScore.LU * 0.3 + finalQ * 0.5 + baseScore.O * 0.2),
            adjustments: {
                delta: totalDelta,
                badges,
                reasons: hiddenReasons
            },
            // UI用情報はバッチでは最低限で良いが、保存はしておく
            ui: baseScore.ui
        };

        // E. 確定スコア保存
        await appendEvent({
            userId,
            kind: "luqo_score_fixed",
            text: `【自動確定】Weekly Score (${startDate.slice(0, 10)})`,
            createdAt: new Date().toISOString(),
            payload: {
                ...finalScore,
                startDate,
                endDate,
                isAutoGenerated: true,
            }
        }, supabaseAdmin);

        // F. バンディット学習
        await runBanditLearning(userId, finalScore, endDate);

    } catch (err) {
        logger.error(`[WeeklyBatch] Error processing user ${userId}:`, err);
        // 個別のエラーは握りつぶして次へ
    }
}

async function runBanditLearning(userId: string, finalScore: any, endDate: string) {
    try {
        // 評価期間終了日(endDate)以前の最新の提案を取得
        const { data: suggestions } = await supabaseAdmin
            .from("events")
            .select("payload")
            .eq("user_id", userId)
            .eq("kind", "bandit_suggestion_log")
            .lt("created_at", endDate)
            .order("created_at", { ascending: false })
            .limit(1);

        const targetSuggestion = suggestions && suggestions.length > 0 ? suggestions[0] : null;

        if (!targetSuggestion) {
            logger.info(`[WeeklyBatch] No suggestion found for learning (User: ${userId})`);
            return;
        }

        const { armId, targetDimension } = targetSuggestion.payload;
        const validArmId = armId as BanditArmId | undefined;

        if (validArmId && targetDimension) {
            const dim = targetDimension as "LU" | "Q" | "O";
            const rawScore = finalScore[dim] || 0;

            const currentState = await getBanditState(userId, supabaseAdmin);
            const newState = brain.updateState(currentState, validArmId, rawScore);

            await saveBanditState(userId, newState, supabaseAdmin);

            const reward = brain.sigmoidReward(rawScore);
            logger.info(`[WeeklyBatch] Learned: User=${userId}, Arm=${validArmId}, Reward=${reward.toFixed(3)}`);
        }

    } catch (e) {
        logger.warn(`[WeeklyBatch] Learning failed for ${userId}:`, e);
    }
}
